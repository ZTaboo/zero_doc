## 标量

> 为什么基本类型变量叫标量？

> 在 Rust 中，基本类型变量被称为标量类型（Scalar Types）。标量类型是一种代表单个值的类型，它们可以表示数字、字符、布尔值和指针等数据类型。

标量类型有以下几种：

- 整数类型（Integer types）：表示整数值，包括有符号整数和无符号整数。
- 浮点数类型（Floating-point types）：表示浮点数值，包括单精度和双精度浮点数。
- 布尔类型（Boolean type）：表示真或假值。
- 字符类型（Character type）：表示单个 Unicode 字符。
- 指针类型（Pointer types）：表示指向内存地址的指针。

这些类型都是标量类型，因为它们表示单个值。相比之下，复合类型（Compound Types）表示多个值，例如元组和数组。

标量类型的特点是它们都是简单的、原子的类型，这些类型的值不可再分解。这些类型的值可以通过复制（copy）的方式进行传递，而不是通过引用（reference）的方式进行传递，这在一些场景下会更加高效。

因此，在 Rust 中，将基本类型变量称为标量类型，意味着它们是简单的、原子的类型，这有助于更好地理解它们的特点和用途。

## 复合类型

1. 
元组（Tuples）：元组是将固定数量的不同类型的值组合在一起的一种方式。它们用括号括起来，每个值用逗号隔开。元组中的每个元素可以通过索引访问，索引从0开始。

2. 
数组（Arrays）：数组是一种固定大小的同类型值的集合，大小在创建时必须指定。数组可以用中括号表示，并通过索引访问，索引从0开始。

3. 
结构体（Structs）：结构体是一种自定义的类型，可以包含多个具有不同类型的值，称为“字段”。结构体可以定义方法，可以实现trait和实现更高级的功能，如“派生”和“宏”。

4. 
枚举（Enums）：枚举是一种自定义类型，可以包含多个具有不同类型的值，称为“变体”。枚举可以用于表示有限的一组可能值的情况。枚举也可以定义方法，并可以实现trait和派生。

5. 
切片（Slices）：切片是对数组或其他类型的连续片段的引用。它们由一个指向起始元素的指针和一个长度组成。切片可以是可变或不可变的，可以使用索引或迭代器访问。

6. 
引用（References）：引用是对值的不可变或可变借用，通过引用可以将值传递给函数或方法，而无需将其所有权移动到函数或方法中。

7. 
指针（Pointers）：指针是指向内存位置的值。在Rust中，通常使用引用而不是指针来避免指针空值和不安全性问题。但是，Rust也支持原始指针，这些指针可以使用不安全代码块中的特殊语法来创建和使用。

8. 
其他复合类型还包括元组结构体（Tuple Structs）和函数指针（Function Pointers）。


## rust的变量传递方式

### 可变引用传递

> 在 Rust 中，变量的传递默认是按值传递。这意味着当一个变量作为参数传递给函数时，它的值会被复制到函数的参数中，而不是传递指向变量的引用或指针。


> 值传递会造成性能开销，所以rust也提供了引用传递和可变引用传递


```rust
// 可变引用传递：使用引用传递时，函数的参数是对变量的引用，而不是变量本身。这样可以避免复制大型数据结构，同时还可以让函数修改变量的值。
fn main() {
    let mut x = 5;
    add_one(&mut x);
    println!("{}", x); // 输出 6
}

fn add_one(num: &mut i32) {
    *num += 1;
}
```

> 注意下面代码中，`&mut` 是必须的，代表是可变的引用传递，如果使用 `&x` 则是不可变引用传递;会报错：


```bash
error[E0594]: cannot assign to `*num`, which is behind a `&` reference
 --> src\bin\tmp.rs:7:5
  |
7 |     *num += 1;
  |     ^^^^^^^^^ `num` is a `&` reference, so the data it refers to cannot be written
  |
help: consider changing this to be a mutable reference
  |
6 | fn get_num(num: &mut i32) {
  |                 ~~~~~~~~

For more information about this error, try `rustc --explain E0594`.
error: could not compile `tmp` due to previous error
```

### 不可变引用传递

> 示例


```rust
fn main() {
    let x = 123;
    get_num(&x)
}

fn get_num(num: &i32) {
    println!("不可变引用传递：{}", num)
}
```

### 引用与借用啥意思？

> 引用的使用方式上面已提及，借用则是将引用参数作为参数传递，则是借用

